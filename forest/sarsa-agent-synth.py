from export import *
from robolog_classes import *
import numpy as np
from typing import List
from sklearn import tree


def tree_paths(d: dict) -> list:
    paths = []

    def tree_paths_aux(d: dict, path_so_far):
        if d["feature"] is None:
            rule = path_so_far + d["value"]
            paths.append(rule)
        else:
            assert (d["feature"] is not None)
            lpath = path_so_far + [(d["feature"], 'leq', d["threshold"])]
            tree_paths_aux(d["left"], lpath)
            rpath = path_so_far + [(d["feature"], 'gt', d["threshold"])]
            tree_paths_aux(d["right"], rpath)

    tree_paths_aux(d, [])
    return paths


num_features = 4
op_map = {'gt': '>', 'leq': '<='}


def path_to_rule_str(path: list) -> str:
    assert (type(path[-1]) == list)
    preds = []
    variables = ['_'] * num_features
    for feat, op, bound in path[:-1]:
        variable = 's' + str(feat)
        variables[feat] = variable
        pred = ' '.join([variable, op_map[op], str(bound)])
        preds.append(pred)
    state_pred = 'state(t, ' + ', '.join(variables) + ')'
    leaf_counts = path[-1]
    max_val = max(leaf_counts)
    response = leaf_counts.index(max_val)
    action_pred = 'action(t, ' + str(response) + ')'
    body = ', '.join([state_pred] + preds)
    return action_pred + ' :- ' + body


def path_to_rule(path: list) -> Rule:
    assert (type(path[-1]) == list)
    preds = []
    variables = ['_'] * num_features
    for feat, op, bound in path[:-1]:
        variable = 's' + str(feat)
        variables[feat] = variable
        pred = Inequality(feat, op, bound)
        preds.append(pred)
    variables = ['t'] + variables   # add time variable
    state_pred = Predicate('state', variables)
    preds.append(state_pred)
    leaf_counts = path[-1]
    response = leaf_counts.index(max(leaf_counts))  # 0 or 1
    action_pred = Predicate('action', ['t', str(response)])
    return Rule(action_pred, preds)


def synthesize(train_data_file: str, max_depth) -> List[Rule]:
    """ Train a decision tree from a .csv file containing
    observations (4 columns of floats) and binary response
    (0,1) generated by  an expert agent (cem, neural, etc.).
    Convert tree to a list of Robolog rules and return.

    Observation:
        Type: Box(4)
        Num     Observation               Min                     Max
        0       Cart Position             -4.8                    4.8
        1       Cart Velocity             -Inf                    Inf
        2       Pole Angle                -0.418 rad (-24 deg)    0.418 rad (24 deg)
        3       Pole Angular Velocity     -Inf                    Inf

    Actions:
        Type: Discrete(2)
        Num   Action
        0     Push cart to the left
        1     Push cart to the right
    """
    rules = []
    agent_data = np.genfromtxt(train_data_file, delimiter=',')
    X = agent_data[:, :-1]
    y = agent_data[:, -1]
    T = tree.DecisionTreeClassifier(max_depth=max_depth)
    T.fit(X, y)
    d = export_dict(T)  # dictionary with tree structure
    paths = tree_paths(d)
    for path in paths:
        rules.append(path_to_rule(path))
    return rules


if __name__ == "__main__":
    data_file = '/Users/ironchefnate/iCloud/Documents/USC/CSCI_699_HRI/project/code/robolog/synth/cp-sarsa-agent/cp-sarsa-data-01'
    agent_rules = synthesize(data_file, 10)
    for rule in agent_rules:
        print(rule)
